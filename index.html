<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHO Recorder</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.0/dist/ffmpeg.min.js"></script>
<script>
    let ffmpeg;
    async function loadFFmpeg() {
        const { createFFmpeg, fetchFile } = FFmpeg;
        ffmpeg = createFFmpeg({ log: true });
        await ffmpeg.load();
        window.FFmpeg = { ffmpeg, fetchFile };
    }
    loadFFmpeg();
</script>
</head>
<body>
    <h1>ECHO Recorder</h1>
    <button id="startButton">Starta inspelning</button>
    <button id="stopButton">Stoppa inspelning</button>
    <label for="formatSelect">Välj filformat:</label>
    <select id="formatSelect">
        <option value="webm" selected>WebM</option>
        <option value="wav">WAV</option>
        <option value="ogg">OGG</option>
    </select>
    <label for="bitrateSelect">Välj bithastighet (kbps):</label>
    <select id="bitrateSelect">
        <option value="8000">8 kbps</option>
        <option value="10000">10 kbps</option>
        <option value="12000">12 kbps</option>
        <option value="14000">14 kbps</option>
        <option value="16000">16 kbps</option>
        <option value="32000">32 kbps</option>
        <option value="64000">64 kbps</option>
        <option value="128000">128 kbps</option>
    </select>
    <a id="download" style="display: none;">Ladda ner inspelad fil</a>
    <p id="status">Klar för inspelning.</p>
    <label for="filterFrequency">Filterfrekvens (Hz):</label>
    <input type="number" id="filterFrequency" value="2175">
    <label for="filterQ">Q-faktor:</label>
    <input type="number" id="filterQ" value="0.58">
    <p id="filterRange">Tillåtet frekvensomfång: </p>
    <p id="recordingTimer">Inspelad tid: 0 sekunder</p>

    <script>
        if (!navigator.mediaDevices || !window.AudioContext) {
            alert("Din webbläsare stöder inte nödvändiga API:er för att spela in ljud.");
        }

        let audioContext;
        let mediaRecorder;
        let audioChunks = [];
        let stream;
        let recordingStartTime, recordingTimerInterval;

        const startButton = document.getElementById("startButton");
        const stopButton = document.getElementById("stopButton");
        const downloadButton = document.getElementById("download");
        const statusElement = document.getElementById("status");
        const recordingTimer = document.getElementById("recordingTimer");

        startButton.addEventListener("click", startRecording);
        stopButton.addEventListener("click", stopRecording);

        async function startRecording() {
            try {
                updateStatus("Förbereder inspelning...");
                stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                audioContext = new AudioContext();

                const source = audioContext.createMediaStreamSource(stream);
                const bandpassFilter = audioContext.createBiquadFilter();
                bandpassFilter.type = "bandpass";

                const filterFrequencyInput = document.getElementById("filterFrequency");
                const filterQInput = document.getElementById("filterQ");

                bandpassFilter.frequency.value = parseFloat(filterFrequencyInput.value) || 2000;
                bandpassFilter.Q = parseFloat(filterQInput.value) || 1.0;

                filterFrequencyInput.addEventListener("input", updateFilterSettings);
                filterQInput.addEventListener("input", updateFilterSettings);

                function updateFilterSettings() {
                    bandpassFilter.frequency.value = parseFloat(filterFrequencyInput.value);
                    bandpassFilter.Q = parseFloat(filterQInput.value);
                    updateFilterRange();
                }

                function updateFilterRange() {
                    const frequency = parseFloat(filterFrequencyInput.value);
                    const Q = parseFloat(filterQInput.value);
                    const bandwidth = frequency / Q;
                    const minFreq = Math.max(0, frequency - bandwidth / 2);
                    const maxFreq = frequency + bandwidth / 2;
                    document.getElementById("filterRange").textContent = `Tillåtet frekvensomfång: ${minFreq.toFixed(1)} Hz - ${maxFreq.toFixed(1)} Hz`;
                }
                updateFilterRange();

                source.connect(bandpassFilter);
                bandpassFilter.connect(audioContext.destination);

                const format = document.getElementById("formatSelect").value;
                let mimeType;
                switch (format) {
                    case "webm":
                        mimeType = "audio/webm";
                        break;
                    case "wav":
                        mimeType = "audio/wav";
                        break;
                    case "ogg":
                        mimeType = "audio/ogg; codecs=opus";
                        break;
                    default:
                        mimeType = "audio/webm";
                }
                if (MediaRecorder.isTypeSupported(mimeType)) {
                    mediaRecorder = new MediaRecorder(stream, { mimeType, audioBitsPerSecond: parseInt(document.getElementById("bitrateSelect").value) });
                } else {
                    alert('Det valda formatet stöds inte av din webbläsare. Prova ett annat format.');
                    return;
                }

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    updateStatus("Bearbetar ljud...");
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    audioChunks = [];

                    const bitrate = parseInt(document.getElementById("bitrateSelect").value) / 1000;
                    const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                    let filename = `filtered_audio_${elapsedSeconds}s_${bitrate}kbps.${format}`;

                    if (format !== 'webm') {
                        updateStatus(`Konverterar till ${format}...`);
                        console.log(`Starting conversion to ${format} using ffmpeg.js`);
                        try {
                            const data = await FFmpeg.fetchFile(audioBlob);
                            await ffmpeg.FS('writeFile', 'input.webm', data);

                            let outputFormat = format;
                            switch (format) {
                                case 'wav':
                                    outputFormat = 'output.wav';
                                    break;
                                case 'ogg':
                                    outputFormat = 'output.ogg';
                                    break;
                            }

                            await ffmpeg.run('-i', 'input.webm', outputFormat);
                            console.log(`Conversion to ${format} successful.`);

                            const outputData = await ffmpeg.FS('readFile', outputFormat);
                            const outputBlob = new Blob([outputData.buffer], { type: format === 'wav' ? 'audio/wav' : 'audio/ogg' });
                            filename = `filtered_audio_${elapsedSeconds}s_${bitrate}kbps.${format}`;
                            setupDownloadButton(outputBlob, filename);
                        } catch (error) {
                            console.error(`Conversion to ${format} failed:`, error);
                            updateStatus(`Fel vid konvertering till ${format}. Försök igen eller använd ett annat format.`);
                            return;
                        }
                    } else {
                        setupDownloadButton(audioBlob, filename);
                    }

                    updateStatus("Inspelning klar! Klicka på nedladdningsknappen.");
                };

                mediaRecorder.start();
                recordingStartTime = Date.now();
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
                updateStatus("Inspelning startad...");
            } catch (error) {
                console.error("Fel vid inspelning:", error);
                updateStatus("Fel: kunde inte starta inspelningen.");
            }
        }

        function stopRecording() {
            clearInterval(recordingTimerInterval);
            recordingTimer.textContent = 'Inspelad tid: 0 sekunder';
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                try {
                    mediaRecorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                    updateStatus("Inspelning stoppad. Vänta medan filen bearbetas...");
                } catch (error) {
                    console.error("Fel vid stopp av inspelning:", error);
                    updateStatus("Fel: kunde inte stoppa inspelningen korrekt.");
                }
            } else {
                updateStatus("Inspelningen är redan stoppad.");
            }
        }

        function updateRecordingTimer() {
            const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = `Inspelad tid: ${elapsedSeconds} sekunder`;
        }

        function updateStatus(message) {
            statusElement.textContent = message;
        }

        function setupDownloadButton(blob, filename) {
            downloadButton.style.display = "inline-block";
            downloadButton.href = URL.createObjectURL(blob);
            downloadButton.download = filename;
            downloadButton.textContent = "Ladda ner inspelad fil";
        }

    </script>
    <footer style="position: fixed; bottom: 10px; right: 10px; font-size: small; color: #777;">Version 2.02</footer>
</body>
</html>
