<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHO Recorder</title>
</head>
<body>
    <h1>ECHO Recorder</h1>
    <button id="startButton">Starta inspelning</button>
    <button id="stopButton">Stoppa inspelning</button>
    <label for="formatSelect">Välj filformat:</label>
    <select id="formatSelect">
        <option value="webm" selected>WebM</option>
        <option value="wav">WAV</option>
        <option value="mp3">MP3</option>
        <option value="ogg">OGG</option>
    </select>
    <label for="bitrateSelect">Välj bithastighet (kbps):</label>
    <select id="bitrateSelect">
        <option value="8000">8 kbps</option>
        <option value="10000">10 kbps</option>
        <option value="12000">12 kbps</option>
        <option value="14000">14 kbps</option>
        <option value="16000">16 kbps</option>
        <option value="32000">32 kbps</option>
        <option value="64000">64 kbps</option>
        <option value="128000">128 kbps</option>
    </select>
    <a id="download" style="display: none;">Ladda ner inspelad fil</a>
    <p id="status">Klar för inspelning.</p>
    <label for="filterFrequency">Filterfrekvens (Hz):</label>
    <input type="number" id="filterFrequency" value="2000">
    <label for="filterQ">Q-faktor:</label>
    <input type="number" id="filterQ" value="1.0">
    <p id="filterRange">Tillåtet frekvensomfång: </p>

    <script>
        // ECHO_recorder

        if (!navigator.mediaDevices || !window.AudioContext) {
            alert("Din webbläsare stöder inte nödvändiga API:er för att spela in ljud.");
        }

        $1
let recordingStartTime, recordingTimerInterval;

        const recordingTimer = document.createElement('p');
recordingTimer.id = 'recordingTimer';
recordingTimer.textContent = 'Inspelad tid: 0 sekunder';
statusElement.insertAdjacentElement('afterend', recordingTimer);

$1
        const stopButton = document.getElementById("stopButton");
        const downloadButton = document.getElementById("download");
        const statusElement = document.getElementById("status");

        startButton.addEventListener("click", startRecording);
        stopButton.addEventListener("click", stopRecording);

        $1
            recordingStartTime = Date.now();
            recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
            try {
                updateStatus("Förbereder inspelning...");
                
                stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                audioContext = new AudioContext();

                const source = audioContext.createMediaStreamSource(stream);
                const bandpassFilter = audioContext.createBiquadFilter();
                bandpassFilter.type = "bandpass";

                const filterFrequencyInput = document.getElementById("filterFrequency");
                const filterQInput = document.getElementById("filterQ");

                bandpassFilter.frequency.value = parseFloat(filterFrequencyInput.value) || 2175;
                bandpassFilter.Q = parseFloat(filterQInput.value) || 0.58;

                filterFrequencyInput.addEventListener("input", updateFilterSettings);
                filterQInput.addEventListener("input", updateFilterSettings);

                function updateFilterSettings() {
                    bandpassFilter.frequency.value = parseFloat(filterFrequencyInput.value);
                    bandpassFilter.Q = parseFloat(filterQInput.value);
                    updateFilterRange();
                }

                function updateFilterRange() {
                    const frequency = parseFloat(filterFrequencyInput.value);
                    const Q = parseFloat(filterQInput.value);
                    const bandwidth = frequency / Q;
                    const minFreq = Math.max(0, frequency - bandwidth / 2);
                    const maxFreq = frequency + bandwidth / 2;
                    document.getElementById("filterRange").textContent = `Tillåtet frekvensomfång: ${minFreq.toFixed(1)} Hz - ${maxFreq.toFixed(1)} Hz`;
                }
                updateFilterRange();

                source.connect(bandpassFilter);
                bandpassFilter.connect(audioContext.destination);

                const format = document.getElementById("formatSelect").value;
                let mimeType;
                switch (format) {
                    case "webm":
                        mimeType = "audio/webm";
                        break;
                    case "wav":
                        mimeType = "audio/wav";
                        break;
                    case "mp3":
                        mimeType = "audio/mpeg";
                        break;
                    case "ogg":
                        mimeType = "audio/ogg";
                        break;
                    default:
                        mimeType = "audio/webm";
                }
                mediaRecorder = new MediaRecorder(stream, { mimeType, audioBitsPerSecond: parseInt(document.getElementById("bitrateSelect").value) });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    updateStatus("Bearbetar ljud...");
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    audioChunks = [];

                    const format = document.getElementById("formatSelect").value;
                    const filename = `filtered_audio.${format}`;
                    setupDownloadButton(audioBlob, filename);
                    updateStatus("Inspelning klar! Klicka på nedladdningsknappen.");
                };

                mediaRecorder.start();
                updateStatus("Inspelning startad...");
            } catch (error) {
                console.error("Fel vid inspelning:", error);
                updateStatus("Fel: kunde inte starta inspelningen.");
            }
        }

        $1
            clearInterval(recordingTimerInterval);
            recordingTimer.textContent = 'Inspelad tid: 0 sekunder';
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                try {
                    mediaRecorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                    updateStatus("Inspelning stoppad. Vänta medan filen bearbetas...");
                } catch (error) {
                    console.error("Fel vid stopp av inspelning:", error);
                    updateStatus("Fel: kunde inte stoppa inspelningen korrekt.");
                }
            } else {
                updateStatus("Inspelningen är redan stoppad.");
            }
        }

        function updateRecordingTimer() {
            const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = `Inspelad tid: ${elapsedSeconds} sekunder`;
        }

$1
            statusElement.textContent = message;
        }

        function setupDownloadButton(blob, filename) {
            downloadButton.style.display = "inline-block";
            downloadButton.href = URL.createObjectURL(blob);
            downloadButton.download = filename;
            downloadButton.textContent = "Ladda ner inspelad fil";
        }

    </script>
    <footer style="position: fixed; bottom: 10px; right: 10px; font-size: small; color: #777;">Version 1.07</footer>
</body>
</html>
